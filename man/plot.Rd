% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_subgroup_fitted.R, R/plot_subgroup_validated.R
\name{plot.subgroup_fitted}
\alias{plot.subgroup_fitted}
\alias{plot.subgroup_validated}
\title{Plotting results for fitted subgroup identification models}
\usage{
\method{plot}{subgroup_fitted}(x, type = c("density", "boxplot",
  "interaction"), avg.line = TRUE, ...)

\method{plot}{subgroup_validated}(x, type = c("density", "boxplot",
  "interaction"), avg.line = TRUE, ...)
}
\arguments{
\item{x}{fitted object returned by \code{validate.subgrp()} or \code{fit.subgrp()} function}

\item{type}{type of plot. \code{"density"} results in a density plot for the results
across all observations (if \code{x} is from \code{fit.subgrp()}) or if \code{x} is from \code{validate.subgrp()}
across iterations of either the bootstrap or training/test re-fitting. For the latter
case the test results will be plotted. \code{"boxplot"} results in boxplots across all observations/iterations of either
the bootstrap or training/test re-fitting. For the latter
case the test results will be plotted. \code{"interaction"} creates an
interaction plot for the different subgroups (crossing lines here means a meaningful subgroup)}

\item{avg.line}{boolean value of whether or not to plot a line for the average
value in addition to the density (only valid for \code{type = "density"})}

\item{...}{not used}
}
\description{
Plots results for estimated subgroup treatment effects

Plots validation results for estimated subgroup treatment effects
}
\examples{
library(personalized)

set.seed(123)
n.obs  <- 1000
n.vars <- 50
x <- matrix(rnorm(n.obs * n.vars, sd = 3), n.obs, n.vars)


# simulate non-randomized treatment
xbetat   <- 0.5 + 0.5 * x[,21] - 0.5 * x[,41]
trt.prob <- exp(xbetat) / (1 + exp(xbetat))
trt01    <- rbinom(n.obs, 1, prob = trt.prob)

trt      <- 2 * trt01 - 1

# simulate response
delta <- 2 * (0.5 + x[,2] - x[,3] - x[,11] + x[,1] * x[,12])
xbeta <- x[,1] + x[,11] - 2 * x[,12]^2 + x[,13]
xbeta <- xbeta + delta * trt

# continuous outcomes
y <- drop(xbeta) + rnorm(n.obs, sd = 2)

# create function for fitting propensity score model
prop.func <- function(x, trt)
{
    # fit propensity score model
    propens.model <- cv.glmnet(y = trt,
                               x = x, family = "binomial")
    pi.x <- predict(propens.model, s = "lambda.min",
                    newx = x, type = "response")[,1]
    pi.x
}

subgrp.model <- fit.subgrp(x = x, y = y,
                           trt = trt01,
                           propensity.func = prop.func,
                           family = "gaussian",
                           loss   = "sq_loss_lasso",
                           nfolds = 5)              # option for cv.glmnet

subgrp.model$subgroup.trt.effects

plot(subgrp.model)
library(personalized)

set.seed(123)
n.obs  <- 1000
n.vars <- 50
x <- matrix(rnorm(n.obs * n.vars, sd = 3), n.obs, n.vars)


# simulate non-randomized treatment
xbetat   <- 0.5 + 0.5 * x[,21] - 0.5 * x[,41]
trt.prob <- exp(xbetat) / (1 + exp(xbetat))
trt01    <- rbinom(n.obs, 1, prob = trt.prob)

trt      <- 2 * trt01 - 1

# simulate response
delta <- 2 * (0.5 + x[,2] - x[,3] - x[,11] + x[,1] * x[,12])
xbeta <- x[,1] + x[,11] - 2 * x[,12]^2 + x[,13]
xbeta <- xbeta + delta * trt

# continuous outcomes
y <- drop(xbeta) + rnorm(n.obs, sd = 2)

# create function for fitting propensity score model
prop.func <- function(x, trt)
{
    # fit propensity score model
    propens.model <- cv.glmnet(y = trt,
                               x = x, family = "binomial")
    pi.x <- predict(propens.model, s = "lambda.min",
                    newx = x, type = "response")[,1]
    pi.x
}

subgrp.model <- fit.subgrp(x = x, y = y,
                           trt = trt01,
                           propensity.func = prop.func,
                           family = "gaussian",
                           loss   = "sq_loss_lasso",
                           nfolds = 5)              # option for cv.glmnet

subgrp.model$subgroup.trt.effects

x.test <- matrix(rnorm(10 * n.obs * n.vars, sd = 3), 10 * n.obs, n.vars)


# simulate non-randomized treatment
xbetat.test   <- 0.5 + 0.5 * x.test[,21] - 0.5 * x.test[,41]
trt.prob.test <- exp(xbetat.test) / (1 + exp(xbetat.test))
trt01.test    <- rbinom(10 * n.obs, 1, prob = trt.prob.test)

trt.test      <- 2 * trt01.test - 1

# simulate response
delta.test <- 2 * (0.5 + x.test[,2] - x.test[,3] - x.test[,11] + x.test[,1] * x.test[,12])
xbeta.test <- x.test[,1] + x.test[,11] - 2 * x.test[,12]^2 + x.test[,13]
xbeta.test <- xbeta.test + delta.test * trt.test

y.test <- drop(xbeta.test) + rnorm(10 * n.obs, sd = 2)

valmod <- validate.subgrp(subgrp.model, B = 10,
                          method = "training_test",
                          train.fraction = 0.75)
valmod$avg.results

plot(valmod)
}
\seealso{
\code{\link[personalized]{fit.subgrp}} for function which fits subgroup identification models.

\code{\link[personalized]{validate.subgrp}} for function which creates validation results
and \code{\link[personalized]{fit.subgrp}} for function which fits subgroup identification models.
}

